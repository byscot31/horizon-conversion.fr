// src/pages/zones/[zone]/[ville]/[service]/[cible].astro
import services from "../data/services.json";
import villes from "../data/villes.json";
import cibles from "../data/cibles.json";

const ZONES_ALLOWED = new Set(["sud-oise", "nord-val-doise"]);

// services autorisés par segment (exemple simple)
const SERVICE_BY_SEGMENT: Record<string, string[]> = {
  volume: ["svc-google-ads", "svc-meta-ads", "svc-google-business-profile", "svc-tracking"],
  mix: ["svc-google-ads", "svc-google-business-profile", "svc-seo-local", "svc-landing-page", "svc-tracking"],
  premium: ["svc-seo-local", "svc-landing-page", "svc-google-business-profile", "svc-tracking"]
};

// limite d’explosion
const MAX_CIBLES_PER_CITY = 3;
const MAX_SERVICES_PER_CITY = 3;

// “money pages” (facultatif) : tu peux piloter la prod
const TOP_CIBLES = ["cible-artisans", "cible-tpe", "cible-professions-liberales", "cible-commerces", "cible-pme"];
const TOP_CITY_SLUGS = new Set(["chantilly", "senlis", "luzarches", "domont", "gouvieux", "lamorlaye", "sarcelles"]);

function pickDeterministic<T>(arr: T[], seed: string, n: number): T[] {
  // petit pick déterministe (simple, sans lib)
  let h = 0;
  for (let i = 0; i < seed.length; i++) h = (h * 31 + seed.charCodeAt(i)) >>> 0;
  const out: T[] = [];
  const used = new Set<number>();
  while (out.length < Math.min(n, arr.length)) {
    h = (h * 1103515245 + 12345) >>> 0;
    const idx = h % arr.length;
    if (!used.has(idx)) { used.add(idx); out.push(arr[idx]); }
  }
  return out;
}

export function getStaticPaths() {
  const serviceList = Object.values(services);
  const cityList = Object.values(villes).filter((c: any) => ZONES_ALLOWED.has(c.zoneSlug));
  const cibleList = Object.values(cibles);

  const paths: any[] = [];

  for (const city of cityList) {
    const zone = city.zoneSlug;
    if (!ZONES_ALLOWED.has(zone)) continue;

    // option : focus sur villes prioritaires (sinon commente)
    // if (!TOP_CITY_SLUGS.has(city.slug)) continue;

    // segment “dominant” de la ville (fallback mix)
    const citySegment = (city.segment || "mix") as "volume" | "mix" | "premium";

    // services autorisés par segment ville
    const allowedServiceIds = SERVICE_BY_SEGMENT[citySegment] || [];
    const allowedServices = serviceList.filter((s: any) => allowedServiceIds.includes(s.id));

    const servicesPicked = pickDeterministic(allowedServices, `svc|${city.id}`, MAX_SERVICES_PER_CITY);

    for (const svc of servicesPicked) {
      // cibles compatibles (segment proche)
      const compatibleCibles = cibleList.filter((cb: any) => {
        // règle simple : premium ville → exclure cibles volume “dures” (optionnel)
        if (citySegment === "premium" && cb.segment === "volume") return false;
        // volume ville → éviter “pme” si tu veux (optionnel)
        if (citySegment === "volume" && cb.segment === "premium") return false;
        return true;
      });

      const wanted = compatibleCibles
        .filter((cb: any) => TOP_CIBLES.includes(cb.id))
        .concat(compatibleCibles.filter((cb: any) => !TOP_CIBLES.includes(cb.id)));

      const ciblesPicked = pickDeterministic(wanted, `cible|${city.id}|${svc.id}`, MAX_CIBLES_PER_CITY);

      for (const cb of ciblesPicked) {
        paths.push({
          params: {
            zone,
            ville: city.slug,
            service: svc.slug,
            cible: cb.slug
          }
        });
      }
    }
  }

  return paths;
}
